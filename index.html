<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Interactive Bézier Curve with Physics</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0f1220;
    }
    canvas {
      display: block;
    }
    .hint {
      position: fixed;
      bottom: 12px;
      left: 12px;
      font-size: 12px;
      color: #eaeaf0;
      opacity: 0.7;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="hint">Move the mouse to interact with the curve</div>

  <script>
   //canva setup
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    window.addEventListener("resize", resize);
    resize();
    // Vector utilities
  
    function vec(x = 0, y = 0) {
      return { x, y };
    }

    function add(a, b) {
      return vec(a.x + b.x, a.y + b.y);
    }

    function sub(a, b) {
      return vec(a.x - b.x, a.y - b.y);
    }

    function mul(v, s) {
      return vec(v.x * s, v.y * s);
    }

    function length(v) {
      return Math.hypot(v.x, v.y);
    }

    function normalize(v) {
      const l = length(v) || 1;
      return vec(v.x / l, v.y / l);
    }
    // Control points

    const P0 = vec(); // fixed
    const P1 = vec(); //dynamic
    const P2 = vec(); //fix
    const P3 = vec(); //dynamic

    const V1 = vec();
    const V2 = vec();

    function updateEndpoints() {
      P0.x = canvas.width * 0.15;
      P0.y = canvas.height * 0.5;

      P3.x = canvas.width * 0.85;
      P3.y = canvas.height * 0.5;
    }

    // Initial positions for dynamic
    P1.x = window.innerWidth * 0.35;
    P1.y = window.innerHeight * 0.5;
    P2.x = window.innerWidth * 0.65;
    P2.y = window.innerHeight * 0.5;


    // Mouse input

    const mouse = vec();
    let mouseActive = false;

    canvas.addEventListener("mousemove", (e) => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
      mouseActive = true;
    });
    // Bézier math

    function bezierPoint(t, p0, p1, p2, p3) {
      const u = 1 - t;

      return add(
        add(
          mul(p0, u * u * u),
          mul(p1, 3 * u * u * t)
        ),
        add(
          mul(p2, 3 * u * t * t),
          mul(p3, t * t * t)
        )
      );
    }

    function bezierTangent(t, p0, p1, p2, p3) {
      const u = 1 - t;

      return add(
        add(
          mul(sub(p1, p0), 3 * u * u),
          mul(sub(p2, p1), 6 * u * t)
        ),
        mul(sub(p3, p2), 3 * t * t)
      );
    }
    // Spring-damper physics

    const SPRING_K = 25;
    const DAMPING = 6;

    function updateSpring(P, V, target, dt) {
      const force = sub(target, P);
      const accel = sub(mul(force, SPRING_K), mul(V, DAMPING));

      V.x += accel.x * dt;
      V.y += accel.y * dt;

      P.x += V.x * dt;
      P.y += V.y * dt;
    }
    // Drawing helpers

    function drawPoint(p, r, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
      ctx.fill();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw curve
      ctx.strokeStyle = "#7cf3ff";
      ctx.lineWidth = 2;
      ctx.beginPath();

      for (let t = 0; t <= 1.001; t += 0.01) {
        const p = bezierPoint(t, P0, P1, P2, P3);
        if (t === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }

      ctx.stroke();

      // Draw tangents
      ctx.strokeStyle = "#ffb86c";
      ctx.lineWidth = 1;

      for (let t = 0; t <= 1.001; t += 0.1) {
        const p = bezierPoint(t, P0, P1, P2, P3);
        const tan = normalize(bezierTangent(t, P0, P1, P2, P3));

        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + tan.x * 25, p.y + tan.y * 25);
        ctx.stroke();
      }

      // Draw control polygon
      ctx.strokeStyle = "#444a88";
      ctx.beginPath();
      ctx.moveTo(P0.x, P0.y);
      ctx.lineTo(P1.x, P1.y);
      ctx.lineTo(P2.x, P2.y);
      ctx.lineTo(P3.x, P3.y);
      ctx.stroke();

      // Draw control points
      drawPoint(P0, 5, "#ffffff");
      drawPoint(P1, 6, "#ff79c6");
      drawPoint(P2, 6, "#ff79c6");
      drawPoint(P3, 5, "#ffffff");
    }
    // Animation loop
 
    let lastTime = performance.now();

    function animate(time) {
      const dt = Math.min((time - lastTime) / 1000, 0.033);
      lastTime = time;

      updateEndpoints();

      const center = vec(canvas.width / 2, canvas.height / 2);
      const offset = mouseActive ? sub(mouse, center) : vec(0, 0);

      const targetP1 = add(vec(canvas.width * 0.35, canvas.height * 0.5), mul(offset, 0.25));
      const targetP2 = add(vec(canvas.width * 0.65, canvas.height * 0.5), mul(offset, 0.25));

      updateSpring(P1, V1, targetP1, dt);
      updateSpring(P2, V2, targetP2, dt);

      draw();
      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);
  </script>
</body>
</html>
